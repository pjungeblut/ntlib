module;

#include <tuple>
#include <vector>

export module pell_equation;

import base;
import continued_fraction;
import rational;

namespace ntlib {

/**
 * Computes the minimal solution (in a) of Pell's equation:
 * a^2 - d * b^2 = 1.
 *
 * @param d Parameter d, must not be square.
 * @return Values for a and b, minimal in b.
 */
export template<typename T>
std::tuple<T,T> min_pell_solution(T d) {
  std::vector<T> cf = ntlib::quadratic_irrational_cf(d);
  std::size_t period = cf.size() - 1;
  T n;
  if ((bool)(period & 1)) n = 2 * period - 1;
  else n = period - 1;
  ntlib::rational<T> pq =
      ntlib::nth_convergent_quadratic_irrational_cf(n, cf);
  return std::make_tuple(pq.get_numerator(), pq.get_denominator());
}

/**
 * Generates the next solution to Pell's equation given a current and the
 * minimal solution.
 * x^2 - d * y^2 = 1
 *
 * Solutions can be generated by:
 * x_{i+1} = x_0*x_i + d*y_0*y_i
 * y_{i+1} = y_0*x_i + x_0*y_i
 *
 * @param d The parameter d.
 * @param initial The initial solution (the one minimal in x).
 * @param current Any solution.
 * @return The next bigger solution than current (in x).
 */
export template<typename T>
std::tuple<T,T> next_pell_solution(T d, const std::tuple<T,T> &initial,
    const std::tuple<T,T> &current) {
  const auto &[ix, iy] = initial;
  const auto &[cx, cy] = current;
  return std::make_tuple(ix * cx + d * iy * cy, iy * cx + ix * cy);
}

}
