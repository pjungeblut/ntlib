#pragma once

#include <tuple>
#include <vector>

#include "base.hpp"
#include "continued_fraction.hpp"

namespace ntlib {

/**
 * Computes the minimal solution (in a) of Pell's equation:
 * a^2 - d * b^2 = 1.
 *
 * @param d Parameter d, must not be square.
 * @return Values for a and b, minimal in b.
 */
template<typename T>
std::tuple<T,T> min_pell_solution(T d) {
  std::vector<T> cf;
  T period = ntlib::quadratic_irrational_cf(d, cf);
  T n;
  if ((bool)(period & 1)) n = 2 * period - 1;
  else n = period - 1;
  ntlib::rational<T> pq =
      ntlib::nth_convergent_quadratic_irrational_cf(n, cf);
  return std::make_tuple(pq.get_numerator(), pq.get_denominator());
}

/**
 * Generates the next solution to Pell's equation given a current and the
 * minimal solution.
 * x^2 - d * y^2 = 1
 *
 * Solutions can be generated by:
 * x_{i+1} = x_0*x_i + d*y_0*y_i
 * y_{i+1} = y_0*x_i + x_0*y_i
 *
 * @param d The parameter d.
 * @param initial The initial solution (the one minimal in x).
 * @param current Any solution.
 * @return The next bigger solution than current (in x).
 */
template<typename T>
std::tuple<T,T> next_pell_solution(T d, const std::tuple<T,T> &initial,
    const std::tuple<T,T> &current) {
  const auto &[ix, iy] = initial;
  const auto &[cx, cy] = current;
  return std::make_tuple(ix * cx + d * iy * cy, iy * cx + ix * cy);
}

}
