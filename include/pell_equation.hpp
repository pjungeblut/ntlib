#pragma once

#include <tuple>
#include <vector>

#include "base.hpp"
#include "integral.hpp"
#include "continued_fraction.hpp"

namespace ntlib {

/**
 * Computes the minimal solution (in a) of Pell's equation:
 * a^2 - d * b^2 = 1.
 *
 * @param d Parameter d, must not be square.
 * @return Values for a and b, minimal in b.
 */
template<Integral I>
std::tuple<I,I> min_pell_solution(I d) {
  std::vector<I> cf;
  I period = ntlib::quadratic_irrational_cf(d, cf);
  I n;
  if ((bool)(period & 1)) n = 2 * period - 1;
  else n = period - 1;
  ntlib::rational<I> pq =
      ntlib::nth_convergent_quadratic_irrational_cf(n, cf);
  return std::make_tuple(pq.get_numerator(), pq.get_denominator());
}

/**
 * Generates the next solution to Pell's equation given a current and the
 * minimal solution.
 * x^2 - d * y^2 = 1
 *
 * Solutions can be generated by:
 * x_{i+1} = x_0*x_i + d*y_0*y_i
 * y_{i+1} = y_0*x_i + x_0*y_i
 *
 * @param d The parameter d.
 * @param initial The initial solution (the one minimal in x).
 * @param current Any solution.
 * @return The next bigger solution than current (in x).
 */
template<Integral I>
std::tuple<I,I> next_pell_solution(I d, const std::tuple<I,I> &initial,
    const std::tuple<I,I> &current) {
  return std::make_tuple(
      std::get<0>(initial) * std::get<0>(current) +
          d * std::get<1>(initial) * std::get<1>(current),
      std::get<1>(initial) * std::get<0>(current) +
          std::get<0>(initial) * std::get<1>(current));
}

}
