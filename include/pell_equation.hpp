#pragma once

#include <vector>

#include "base.hpp"
#include "integral.hpp"
#include "continued_fraction.hpp"

namespace ntlib {

/**
 * Computes the minimal solution (in a) of Pell's equation:
 * a^2 - d * b^2 = 1.
 *
 * @param d Parameter d, must not be square.
 * @return Values for a and b, minimal in b.
 */
template<Integral I>
tuple<I,I> min_pell_solution(I d) {
  std::vector<I> cf;
  I period = ntlib::quadratic_irrational_cf(d, cf);
  I n;
  if ((bool)(period & 1)) n = 2 * period - 1;
  else n = period - 1;
  ntlib::rational<I> pq =
      ntlib::nth_convergent_quadratic_irrational_cf(n, cf);
  return tuple<I,I> {pq.numerator, pq.denominator};
}

/**
 * Generates the next solution to Pell's equation given a current and the
 * minimal solution.
 * x^2 - d * y^2 = 1
 *
 * Solutions can be generated by:
 * x_{i+1} = x_0*x_i + d*y_0*y_i
 * y_{i+1} = y_0*x_i + x_0*y_i
 *
 * @param d The parameter d.
 * @param initial The initial solution (the one minimal in x).
 * @param current Any solution.
 * @return The next bigger solution than current (in x).
 */
template<Integral I>
tuple<I,I> next_pell_solution(I d, const tuple<I,I> &initial,
    const tuple<I,I> &current) {
  return tuple<I,I> {
      initial.a * current.a + d * initial.b * current.b,
      initial.b * current.a + initial.a * current.b};
}

}
